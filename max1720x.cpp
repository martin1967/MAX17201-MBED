/**
 * Name: max1720x
 * Author: Luka Mustafa - Institute IRNAS Race { info@irnas.eu }
 * Version: 1.0
 * Description: A library for interfacing the MAXIM MAX17201/MAX17205
 * 				Li+ fuel gauges.
 * Source: https://github.com/pAIgn10/max1720x
 * License: Copyright (c) 2017 Nick Lamprianidis 
 *          This library is licensed under the GPL license
 *          http://www.opensource.org/licenses/mit-license.php
 * Inspiration: The library is inspired by: https://github.com/pAIgn10/max1720x
 * Filename: max1720x.cpp
 * File description: Definitions and methods for the max1720x library
 */


#include <mbed.h>
#include "max1720x.h"
I2C i2c(p28, p29);
#define Rsense 0.5f 
//page 82
// MAX1720X register addresses in const char
const int  MAX1720X_ADDR			= 0x36;//FuelGauge m5 addr need to write message.
const char MAX1720X_STATUS_ADDR		= 0x00; // Contains alert status and chip status
const char MAX1720X_VCELL_ADDR		= 0x09; // Lowest cell voltage of a pack, or the cell voltage for a single cell
const char MAX1720X_REPSOC_ADDR		= 0x06; // Reported state of charge
const char MAX1720X_REPCAP_ADDR		= 0x05; // Reported remaining capacity
const char MAX1720X_TEMP_ADDR		= 0x08; // Temperature
const char MAX1720X_CURENT_ADDR		= 0x0A; // Battery current
const char MAX1720X_TTE_ADDR		= 0x11; // Time to empty
const char MAX1720X_TTF_ADDR		= 0x20; // Time to full
const char MAX1720X_CAPACITY_ADDR	= 0x10; // Full capacity estimation
const char MAX1720X_VBAT_ADDR		= 0xDA; // Battery pack voltage
const char MAX1720X_AVCELL_ADDR		= 0x17; // Battery cycles
const char MAX1720X_COMMAND_ADDR	= 0x60; // Command register
const char MAX1720X_CONFIG2_ADDR	= 0xbb; // Command register
const char MAX1720X_QH				= 0x4d; // register displays the raw coulomb count generated by the device in mah
const char MAX1720X_Timer			= 0x3E; // The Timer register LSb is equal to 175.8ms giving a full-scale range of 0 to 3.2 hours.
const char MAX1720X_TimerH			= 0xBE; // An LSb of 3.2 hours gives a full-scale range for the register of up to 23.94 years.
const char MAX1720X_Shadow_ROM_addr = 0x0B; // Shadow ROM addr need to write message to NonVolatile memory. Addr changes 180h–1FFh->80h–FFh. Example,0x019D->0x009D(0x9D)


max1720x::max1720x(int dev_address)
{
	dev_ADDR = dev_address;
};

uint16_t max1720x::write2b(char mem_adr, uint16_t comand)
// mem_adr - MAX1720X shadow ROM register adress 
// comand - contain of shadow ROM register
{
	i2c.start();
	char write_data[3];
	write_data[0] = mem_adr;
	write_data[1] = (uint8_t)(comand >> 8);
	write_data[2] =  (uint8_t)comand;
	/*i2c.write(MAX1720X_Shadow_ROM_addr, write_data, 3);*/
	i2c.write(0x16, write_data, 3);
}
uint16_t max1720x::write(char dev_ADDR, char comand)
// MAX1720X register addresses=comand
{
	i2c.start();										
	char write_data[1];
	write_data[0] = comand;
	i2c.write(dev_ADDR, write_data, 1);					
}

uint16_t max1720x::read(char dev_ADDR)
{
	char read_data[2];
	i2c.start();
	i2c.read(dev_ADDR, read_data, 2);						
	uint16_t combined = (read_data[1] << 8) | read_data[0];  // LSB or-ed with MSB
	return combined;
}

 //Returns a measurement of the voltage of the connected LiIon Polymer battery
float max1720x::getVoltage()
{	
	max1720x::write(dev_ADDR, MAX1720X_VCELL_ADDR);
	uint16_t voltage0 = read(dev_ADDR);
	float voltage = 0.078125*voltage0;
	return voltage;											//return voltage; // //calculate actual value and return in mV
}

uint16_t max1720x::getTime()
{
	max1720x::write(dev_ADDR, MAX1720X_Timer);
	uint16_t time = read(dev_ADDR)*0.1758;
	return time;											//return current;//calculate actual value as 0.0015625 mV/Ohm
}

uint16_t max1720x::getTimeH()
{
	max1720x::write(dev_ADDR, MAX1720X_TimerH);
	uint16_t timeH = read(dev_ADDR);
	return timeH;											//return current;//calculate actual value as 0.0015625 mV/Ohm
}

float max1720x::getCurrent()
{
	max1720x::write(dev_ADDR, MAX1720X_CURENT_ADDR);	
	float current1 = (read(dev_ADDR)*0.0015625)*2;
	return current1;											//return current;//calculate actual value as 0.0015625 mV/Ohm/  Rsense(0.5=500mOhm)
}

float max1720x::getTemperature()
{
	max1720x::write(dev_ADDR, MAX1720X_TEMP_ADDR);
	float temperature = read(dev_ADDR)/256;
    return temperature;										//return temperature;//calculate actual value as 0.0015625 mV/Ohm
}

// Returns the relative state of charge of the connected LiIon Polymer battery
// as a percentage of the full capacity w/ resolution 1/256%
float max1720x::getSOC()
{
	max1720x::write(dev_ADDR, MAX1720X_REPSOC_ADDR);
	float soc = read(dev_ADDR)/256;
	return soc;								
}

// RepCap or reported capacity is a filtered version of the AvCap register that prevents large jumps in the reported value caused by changes in the application such as abrupt changes in temperature or load current. 
float max1720x::getCapacity()
{
	max1720x::write(dev_ADDR, MAX1720X_REPCAP_ADDR);
	float capacity = read(dev_ADDR)*0.005 / Rsense;
    return capacity;//calculate actual value as 0.005 mVh/Ohm/ Rsense(0.5=500mOhm)
}

// The TTE register holds the estimated time to empty for the application under present temperature and load conditions 
float max1720x::getTTE()
{
	max1720x::write(dev_ADDR, MAX1720X_TTE_ADDR);
	float capacity = 5.625*read(dev_ADDR);
    return capacity;//calculate actual value as value*5.625s
}

// The TTF register holds the estimated time to full for the application under present conditions. 
float max1720x::getTTF()
{
	max1720x::write(dev_ADDR, MAX1720X_TTF_ADDR);
	float capacity = 5.625*read(dev_ADDR);
	return capacity;//calculate actual value as value*5.625s
}

// Status Register (000h) The Status register maintains all flags related to alert thresholds and battery insertion or removal.
uint16_t max1720x::getStatus()
{
	max1720x::write(dev_ADDR, MAX1720X_STATUS_ADDR);
	uint16_t status = read(dev_ADDR);
	return status;
}

float max1720x::getCapacity_coulomb()
{
	max1720x::write(dev_ADDR, MAX1720X_QH);
	float capacity_coulomb = read(dev_ADDR)*0.005 / Rsense;
	return capacity_coulomb;//calculate actual value as 0.005 mVh/Ohm / Rsense(0.5=500mOhm)
}

void max1720x::init()
{
	max1720x::write2b(0x9d, 0x0EA4);//Filtr of ADC config
	max1720x::write2b(0x9E, 0x5A61);//Vempty/Vfull config
	max1720x::write2b(0xB3, 0x0E42);//Design capacity of battery=3650mAh
	max1720x::write2b(0xB4, 0x801C);//Config Hibernate mode
	max1720x::write2b(0xB8, 0x0142);//Config0
	max1720x::write2b(0xBA, 0xFC0A);//Config2
	max1720x::write2b(0xC8, 0xC000);//Correction of mesurement
	max1720x::write2b(0xCF, 0x1388);//Rsense=0.5 Ohm	

	max1720x::reset();
	wait_ms(500);
}

uint8_t max1720x::HWreset()
//  HW  reset!!!
//Need write 0x000F to 0x0060
{
	i2c.start();
	char write_data_1[3];
	write_data_1[0] = MAX1720X_COMMAND_ADDR;
	write_data_1[1] = 0x00;
	write_data_1[2] = 0x0F;
	i2c.write(dev_ADDR, write_data_1, 3);
	return 1;
}

uint8_t max1720x::reset()
 // fuel gauge reset, no HW  reset!!!
{//Need write 0x0001 to 0xBB
	i2c.start();										
	char write_data_1[3];
	write_data_1[0] = MAX1720X_CONFIG2_ADDR;
	write_data_1[1] = 0x00;
	write_data_1[2] = 0x01;
	i2c.write(dev_ADDR, write_data_1, 3);
	return 1;
}




